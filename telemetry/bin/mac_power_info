#!/usr/bin/env python
# Copyright 2014 The Chromium Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.
"""Standalone utility, prints idle and interrupt wakeups given a list of pids on
the command line.

Usage:
  $ sudo mac_power_info [[[pid1] pid2], ...]"""

import ctypes
import ctypes.util
import json
import os
import platform
import sys


class TaskPowerInfo(ctypes.Structure):
  """task_power_info struct as returned by task_info() call."""
  _pack_ = 4
  _fields_ = [("total_user", ctypes.c_uint64),
              ("total_system", ctypes.c_uint64),
              ("task_interrupt_wakeups", ctypes.c_uint64),
              ("task_platform_idle_wakeups", ctypes.c_uint64),
              ("task_timer_wakeups_bin_1", ctypes.c_uint64),
              ("task_timer_wakeups_bin_2", ctypes.c_uint64)]

  TASK_POWER_INFO = 21

  def __init__(self):
    self.size = ctypes.sizeof(self)
    super(TaskPowerInfo, self).__init__()


def WakeupCountForPID(pid):
  """Given a pid, return power info for that pid."""
  # Define some mach types.
  natural_t = ctypes.c_uint
  mach_msg_type_number_t = natural_t
  mach_port_t = natural_t

  lib_system = ctypes.CDLL(ctypes.util.find_library("System"))
  task_port = mach_port_t()
  ret = lib_system.task_for_pid(
      lib_system.mach_task_self(),
      pid,
      ctypes.byref(task_port))

  if ret != 0:
    raise ValueError("task_for_pid(%d) failed, returned %d" % (pid, ret))

  try:
    power_info = TaskPowerInfo()
    count = mach_msg_type_number_t(power_info.size / ctypes.sizeof(natural_t))
    ret = lib_system.task_info(task_port,
        TaskPowerInfo.TASK_POWER_INFO,
        ctypes.byref(power_info),
        ctypes.byref(count))
    if ret != 0:
      raise ValueError("task_info() failed, returned %d" % ret)

    return [power_info.task_interrupt_wakeups,
        power_info.task_platform_idle_wakeups]
  finally:
    if task_port:
      lib_system.mach_port_deallocate(lib_system.mach_task_self(), task_port)

def main(args):
  # ----- Sanity checks -----
  running_as_root = os.geteuid() == 0
  if not running_as_root:
    print >> sys.stderr, "Error: %s must be run as root." % args[0]
    return -1

  if sys.platform != 'darwin':
    print >> sys.stderr, "Error: %s Can only run on a Mac." % args[0]
    return -1

  mac_version = platform.mac_ver()[0].split('.')
  mac_version = [int(x) for x in mac_version]
  os_x_1084_or_later = mac_version[1] > 8 or (
      mac_version[1] == 8 and mac_version >= 4)
  if not os_x_1084_or_later:
    print >> sys.stderr, "Error: %s can only run on OS 10.8.4 or later." % (
        args[0])
    return -1

  pids = [int(x) for x in args[1:]]
  if not len(pids):
    print >> sys.stderr, "Error: No PIDs supplied on command line."
    return -1

  # ----- Do the work -----
  output = []

  try:
    for p in pids:
      (interrupt_wakeups, idle_wakeups) = WakeupCountForPID(p)
      output.append({'pid' : p,
          'interrupt_wakeup_count' : interrupt_wakeups,
          'package_idle_exit_count': idle_wakeups})
  except ValueError as e:
    print >> sys.stderr, e
    return -1

  print json.dumps(output)
  return 0

if __name__ == '__main__':
  sys.exit(main(sys.argv))
